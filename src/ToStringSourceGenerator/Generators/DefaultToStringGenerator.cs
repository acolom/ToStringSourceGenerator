using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using ToStringSourceGenerator.Utils;
using ToStringSourceGenerator.Attributes;
using System.Diagnostics;
using Microsoft.VisualStudio.Utilities;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ToStringSourceGenerator.Generators
{
    public sealed class DefaultToStringGenerator
    {
        private const string _valuesSeparator = ",";
        private const string _propertySeparator = ":";
        public static bool ShouldUseGenerator(INamedTypeSymbol type)
        {
            return CompilationHelper.SymbolContainsAttribute<AutoToStringAttribute>(type);
        }
        public static void WriteTo(IndentedTextWriter indentedTextWriter, SourceGeneratorContext context, INamedTypeSymbol type)
        {
            if (!CompilationHelper.IsPartial(type))
            {
                Report_ClassMustBePartial(context, type);
            }
            else if (ContainsToStringMethodWithNoArguments(type))
            {
                Report_ClassContainsToStringWithNoArguments(context, type, GetToStringMethodWithNoArguments(type));
            }
            else if (!GetSymbolsForToString(type).Any())
            {
                Report_NoPropertiesFoundOnMethod(context, type);
            }
            else
            {
                WritePartialClassSourceText(indentedTextWriter, context, type);
            }

        }

        private static void WritePartialClassSourceText(IndentedTextWriter indentedTextWriter, SourceGeneratorContext context, INamedTypeSymbol type)
        {
            // TODO Comprobar si contiene to string

            indentedTextWriter.WriteLine();
            indentedTextWriter.WriteLine($"namespace {type.ContainingNamespace}");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;
            indentedTextWriter.WriteLine("using System;");
            indentedTextWriter.WriteLine();
            indentedTextWriter.WriteLine($"partial class {type.Name}");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;

            indentedTextWriter.WriteLine("public override string ToString()");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;

            //indentedTextWriter.WriteLine("return \"I am autogenerated\";");
            WriteToStringMethodBody(indentedTextWriter, context, type);
            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");

            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");

            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");
        }
        private static void WriteToStringMethodBody(IndentedTextWriter indentedTextWriter, SourceGeneratorContext context, INamedTypeSymbol type)
        {
            indentedTextWriter.Write("return $\"");
            var stringValueInMethod = new StringBuilder();

            var count = 0;
            foreach (var propertySymbol in GetSymbolsForToString(type))
            {
                stringValueInMethod.Append(count > 0 ? " " : string.Empty);
                stringValueInMethod.Append($"{propertySymbol.Name}{_propertySeparator}"); // Add propertyName + separator
                stringValueInMethod.Append($" "); // Add space

                WritePropertyValueToStringRepresentation(stringValueInMethod, context, propertySymbol);

                stringValueInMethod.Append($"{ _valuesSeparator}"); // Add value separator

                count++;
            }

            // remove traling separator
            stringValueInMethod.Length -= _valuesSeparator.Length;
            indentedTextWriter.Write(stringValueInMethod.ToString());
            indentedTextWriter.Write("\";");
        }

        public static void WritePropertyValueToStringRepresentation(StringBuilder sb, SourceGeneratorContext context, IPropertySymbol namedTypeSymbol)
        {
            var objectDelimiter = GetSeparatorFor(namedTypeSymbol.Type.SpecialType);

            sb.Append(GetOpeningSeparatorFor(objectDelimiter)); 

            var attributeFormatString = CompilationHelper.GetAttributesOfType<FormatToStringAttribute>(namedTypeSymbol).SingleOrDefault();
            if (attributeFormatString != null)
            {
                var format = GetFirstConstructorArgumentValueOfAttribute(attributeFormatString);
                sb.Append($"{{{namedTypeSymbol.Name}:{format}}}");
            }
            else
            {
                sb.Append($"{{{namedTypeSymbol.Name}}}");
            }
            
            sb.Append(GetClosingSeparatorFor(objectDelimiter));
        }

        private static void Report_MultiplesFormatStringAttributesApplied(SourceGeneratorContext context, INamedTypeSymbol type)
        {
            // TODO Reportar mejor la localizacion
            context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                nameof(FormatToStringAttribute),
                nameof(FormatToStringAttribute),
                $"Multiples attributes form No properties found in '{type.ContainingNamespace}.{type.Name}' type to fill ToString() method.",
                $"{nameof(AutoToStringAttribute)}",
                DiagnosticSeverity.Warning,
                true),
                type.Locations.FirstOrDefault() ?? Location.None
                ));
        }

        private static void Report_NoPropertiesFoundOnMethod(SourceGeneratorContext context, INamedTypeSymbol type)
        {
            // TODO Reportar mejor la localizacion
            context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                nameof(AutoToStringAttribute),
                nameof(AutoToStringAttribute),
                $"No properties found in '{type.ContainingNamespace}.{type.Name}' type to fill ToString() method.",
                $"{nameof(AutoToStringAttribute)}",
                DiagnosticSeverity.Warning,
                true),
                type.Locations.FirstOrDefault() ?? Location.None
                ));
        }
        private static void Report_ClassMustBePartial(SourceGeneratorContext context, INamedTypeSymbol type)
        {
            // TODO Reportar mejor la localizacion
            context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                nameof(AutoToStringAttribute),
                nameof(AutoToStringAttribute),
                $"'{type.ContainingNamespace}.{type.Name}' class must be partial, if '{typeof(AutoToStringAttribute).FullName}' is used",
                $"{nameof(AutoToStringAttribute)}",
                DiagnosticSeverity.Warning,
                true),
                type.Locations.FirstOrDefault() ?? Location.None
                ));
        }
        private static void Report_ClassContainsToStringWithNoArguments(SourceGeneratorContext context, INamedTypeSymbol type, IMethodSymbol method)
        {
            // TODO Reportar mejor la localizacion
            context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                nameof(AutoToStringAttribute),
                nameof(AutoToStringAttribute),
                $"Method 'ToString()' can not be overriden, in type '{type.ContainingNamespace}.{type.Name}' if has attribute '{typeof(AutoToStringAttribute).FullName}'",
                $"{nameof(AutoToStringAttribute)}",
                DiagnosticSeverity.Error,
                true),
                method.Locations.FirstOrDefault() ?? Location.None
                ));
        }
        private static bool ContainsToStringMethodWithNoArguments(ITypeSymbol type)
        {
            return GetToStringMethodWithNoArguments(type) != null;
        }
        private static IEnumerable<IPropertySymbol> GetSymbolsForToString(INamedTypeSymbol type)
        {
            foreach (var typeProperty in type.GetMembers().Where(t => t.Kind == SymbolKind.Property))
            {
                if (typeProperty is IPropertySymbol propertySymbol)
                {
                    var visible = propertySymbol.DeclaredAccessibility == Accessibility.Public || propertySymbol.DeclaredAccessibility == Accessibility.Internal;
                    var containsSkipAttribute = CompilationHelper.SymbolContainsAttribute<SkipToStringAttribute>(propertySymbol);

                    if (visible && !containsSkipAttribute)
                    {
                        yield return propertySymbol;
                    }
                }
            }
        }

        private static IMethodSymbol GetToStringMethodWithNoArguments(ITypeSymbol type)
        {
            var toStringMembers = type.GetMembers("ToString");
            foreach (var toStringMember in toStringMembers)
            {
                if (toStringMember is IMethodSymbol toStringMethodSymbol)
                {
                    if (toStringMethodSymbol.Parameters.Length == 0)
                        return toStringMethodSymbol;
                }
            }
            return null;
        }

        private static string GetFirstConstructorArgumentValueOfAttribute(AttributeData data)
        {
            var constructorArgument = data.ConstructorArguments.First();
            return (string)constructorArgument.Value;
        }
        private enum Separator {  None, Brace, Array, Quote }

        private static string GetOpeningSeparatorFor(Separator separator)
        {
            switch (separator)
            {
                case Separator.None:
                    return string.Empty;
                case Separator.Brace:
                    return "{{ ";
                case Separator.Array:
                    return "[ ";
                case Separator.Quote:
                    return "\\\"";
                default:
                    throw new System.Exception($"Unexpected separator value: '{separator}'");
            }
        }


        private static string GetClosingSeparatorFor(Separator separator)
        {
            switch (separator)
            {
                case Separator.None:
                    return string.Empty;
                case Separator.Brace:
                    return " }}";
                case Separator.Array:
                    return " ]";
                case Separator.Quote:
                    return "\\\"";
                default:
                    throw new System.Exception($"Unexpected separator value: '{separator}'");
            }
        }


        private static Separator GetSeparatorFor(SpecialType specialType)
        {
            var separator = Separator.None;
            switch (specialType)
            {
                case SpecialType.None:
                case SpecialType.System_Object:
                    separator = Separator.Brace;
                    break;
                case SpecialType.System_Array:
                case SpecialType.System_Collections_IEnumerable:
                case SpecialType.System_Collections_Generic_IEnumerable_T:
                case SpecialType.System_Collections_Generic_IList_T:
                case SpecialType.System_Collections_Generic_ICollection_T:
                case SpecialType.System_Collections_IEnumerator:
                case SpecialType.System_Collections_Generic_IEnumerator_T:
                case SpecialType.System_Collections_Generic_IReadOnlyList_T:
                case SpecialType.System_Collections_Generic_IReadOnlyCollection_T:
                    separator = Separator.Array;
                    break;
                case SpecialType.System_String:
                case SpecialType.System_DateTime:
                    separator = Separator.Quote;
                    break;
                case SpecialType.System_Runtime_CompilerServices_IsVolatile:
                    break;
                
            }
            return separator;
        }
    }
}
