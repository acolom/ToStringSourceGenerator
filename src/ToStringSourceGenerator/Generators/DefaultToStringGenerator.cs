using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using ToStringSourceGenerator.Utils;
using ToStringSourceGenerator.Attributes;
using System.Diagnostics;
using Microsoft.VisualStudio.Utilities;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ToStringSourceGenerator.Generators
{
    public sealed class DefaultToStringGenerator
    {
        private const string _valuesSeparator = ",";
        private const string _propertySeparator = ":";
        
        private readonly SourceGeneratorContext _context;

        public static bool ShouldUseGenerator(INamedTypeSymbol type)
        {
            return CompilationHelper.SymbolContainsAttribute<AutoToStringAttribute>(type);
        }

        public DefaultToStringGenerator(SourceGeneratorContext context)
        {
            _context = context;
        }

        private static DefaultToStringGenerator Create(SourceGeneratorContext context)
        {
            return new DefaultToStringGenerator(context);
        }
        public void WriteType(INamedTypeSymbol type, IndentedTextWriter indentedTextWriter)
        {
            if (!CompilationHelper.IsPartial(type))
            {
                Report_ClassMustBePartial(type);
            }
            else if (ContainsToStringMethodWithNoArguments(type))
            {
                Report_ClassContainsToStringWithNoArguments(type, GetToStringMethodWithNoArguments(type));
            }
            else if (!GetSymbolsForToString(type).Any())
            {
                Report_NoPropertiesFoundOnMethod(type);
            }
            else
            {
                WritePartialClassSourceTextTo(type, indentedTextWriter);
            }

        }

        private void WritePartialClassSourceTextTo(INamedTypeSymbol type, IndentedTextWriter indentedTextWriter)
        {
            // TODO Comprobar si contiene to string

            indentedTextWriter.WriteLine();
            indentedTextWriter.WriteLine($"namespace {type.ContainingNamespace}");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;
            indentedTextWriter.WriteLine("using System;");
            indentedTextWriter.WriteLine();
            indentedTextWriter.WriteLine($"partial class {type.Name}");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;

            indentedTextWriter.WriteLine("public override string ToString()");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;

            //indentedTextWriter.WriteLine("return \"I am autogenerated\";");
            WriteToStringMethodBody(type, indentedTextWriter);
            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");

            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");

            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");
        }
        private void WriteToStringMethodBody(INamedTypeSymbol type, IndentedTextWriter indentedTextWriter)
        {
            indentedTextWriter.Write("return $\"");
            var stringValueInMethod = new StringBuilder();

            var count = 0;
            foreach (var propertySymbol in GetSymbolsForToString(type))
            {
                stringValueInMethod.Append(count > 0 ? " " : string.Empty);
                stringValueInMethod.Append($"{propertySymbol.Name}{_propertySeparator}"); // Add propertyName + separator
                stringValueInMethod.Append($" "); // Add space

                WritePropertyValueToStringRepresentation(stringValueInMethod, propertySymbol);

                stringValueInMethod.Append($"{ _valuesSeparator}"); // Add value separator

                count++;
            }

            // remove traling separator
            stringValueInMethod.Length -= _valuesSeparator.Length;
            indentedTextWriter.Write(stringValueInMethod.ToString());
            indentedTextWriter.Write("\";");
        }
        private void WritePropertyValueToStringRepresentation(StringBuilder sb, IPropertySymbol namedTypeSymbol)
        {
            var propertyVauleEnclosingDelimiter = ObjectSeparatorTokensExtensions.GetSeparatorFor(namedTypeSymbol.Type.SpecialType);
            sb.Append(propertyVauleEnclosingDelimiter.GetOpeningSeparatorFor());

            var attributeFormatString = CompilationHelper.GetAttributesOfType<FormatToStringAttribute>(namedTypeSymbol).SingleOrDefault();
            if (attributeFormatString != null)
            {
                var format = GetFirstConstructorArgumentValueOfAttribute(attributeFormatString);
                sb.Append($"{{{namedTypeSymbol.Name}:{format}}}");
            }
            else
            {
                sb.Append($"{{{namedTypeSymbol.Name}}}");
            }

            sb.Append(propertyVauleEnclosingDelimiter.GetClosingSeparatorFor());
        }
        private void Report_MultiplesFormatStringAttributesApplied(INamedTypeSymbol type)
        {
            // TODO Reportar mejor la localizacion
            _context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                nameof(FormatToStringAttribute),
                nameof(FormatToStringAttribute),
                $"Multiples attributes form No properties found in '{type.ContainingNamespace}.{type.Name}' type to fill ToString() method.",
                $"{nameof(AutoToStringAttribute)}",
                DiagnosticSeverity.Warning,
                true),
                type.Locations.FirstOrDefault() ?? Location.None
                ));
        }
        private void Report_NoPropertiesFoundOnMethod(INamedTypeSymbol type)
        {
            // TODO Reportar mejor la localizacion
            _context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                nameof(AutoToStringAttribute),
                nameof(AutoToStringAttribute),
                $"No properties found in '{type.ContainingNamespace}.{type.Name}' type to fill ToString() method.",
                $"{nameof(AutoToStringAttribute)}",
                DiagnosticSeverity.Warning,
                true),
                type.Locations.FirstOrDefault() ?? Location.None
                ));
        }
        private void Report_ClassMustBePartial(INamedTypeSymbol type)
        {
            // TODO Reportar mejor la localizacion
            _context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                nameof(AutoToStringAttribute),
                nameof(AutoToStringAttribute),
                $"'{type.ContainingNamespace}.{type.Name}' class must be partial, if '{typeof(AutoToStringAttribute).FullName}' is used",
                $"{nameof(AutoToStringAttribute)}",
                DiagnosticSeverity.Warning,
                true),
                type.Locations.FirstOrDefault() ?? Location.None
                ));
        }
        private void Report_ClassContainsToStringWithNoArguments(INamedTypeSymbol type, IMethodSymbol method)
        {
            // TODO Reportar mejor la localizacion
            _context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                nameof(AutoToStringAttribute),
                nameof(AutoToStringAttribute),
                $"Method 'ToString()' can not be overriden, in type '{type.ContainingNamespace}.{type.Name}' if has attribute '{typeof(AutoToStringAttribute).FullName}'",
                $"{nameof(AutoToStringAttribute)}",
                DiagnosticSeverity.Error,
                true),
                method.Locations.FirstOrDefault() ?? Location.None
                ));
        }
        private bool ContainsToStringMethodWithNoArguments(ITypeSymbol type)
        {
            return GetToStringMethodWithNoArguments(type) != null;
        }
        private static IEnumerable<IPropertySymbol> GetSymbolsForToString(INamedTypeSymbol type)
        {
            foreach (var typeProperty in type.GetMembers().Where(t => t.Kind == SymbolKind.Property))
            {
                if (typeProperty is IPropertySymbol propertySymbol)
                {
                    var visible = propertySymbol.DeclaredAccessibility == Accessibility.Public || propertySymbol.DeclaredAccessibility == Accessibility.Internal;
                    var containsSkipAttribute = CompilationHelper.SymbolContainsAttribute<SkipToStringAttribute>(propertySymbol);

                    if (visible && !containsSkipAttribute)
                    {
                        yield return propertySymbol;
                    }
                }
            }
        }
        private static IMethodSymbol GetToStringMethodWithNoArguments(ITypeSymbol type)
        {
            var toStringMembers = type.GetMembers("ToString");
            foreach (var toStringMember in toStringMembers)
            {
                if (toStringMember is IMethodSymbol toStringMethodSymbol)
                {
                    if (toStringMethodSymbol.Parameters.Length == 0)
                        return toStringMethodSymbol;
                }
            }
            return null;
        }
        private static string GetFirstConstructorArgumentValueOfAttribute(AttributeData data)
        {
            var constructorArgument = data.ConstructorArguments.First();
            return (string)constructorArgument.Value;
        }



    }
}
