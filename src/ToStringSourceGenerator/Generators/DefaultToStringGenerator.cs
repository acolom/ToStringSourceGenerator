using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using ToStringSourceGenerator.Utils;

namespace ToStringSourceGenerator.Generators
{
    public sealed class DefaultToStringGenerator
    {
        private const string _valuesSeparator = ",";
        private const string _propertySeparator = ":";
        public static bool ShouldUseGenerator(INamedTypeSymbol type)
        {
            return type.GetAttributes().Any(attr => attr.AttributeClass.Name == nameof(AutoToStringAttribute));
        }
        public static void WriteTo(IndentedTextWriter indentedTextWriter, SourceGeneratorContext context, INamedTypeSymbol type)
        {
            if (!CompilationHelper.IsPartial(type))
            {
                Report_ClassMustBePartial(context, type);
            }
            else if (ContainsToStringMethodWithNoArguments(type))
            {
                Report_ClassContainsToStringWithNoArguments(context, type, GetToStringMethodWithNoArguments(type));
            }
            else if (!GetSymbolsForToString(type).Any())
            {
                Report_NoPropertiesFoundOnMethod(context, type);
            }
            else
            {
                //Debugger.Launch();
                WritePartialClassSourceText(indentedTextWriter, context, type);
            }

        }

        private static void WritePartialClassSourceText(IndentedTextWriter indentedTextWriter, SourceGeneratorContext context, INamedTypeSymbol type)
        {
            // TODO Comprobar si contiene to string

            indentedTextWriter.WriteLine();
            indentedTextWriter.WriteLine($"namespace {type.ContainingNamespace}");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;
            indentedTextWriter.WriteLine("using System;");
            indentedTextWriter.WriteLine();
            indentedTextWriter.WriteLine($"partial class {type.Name}");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;

            indentedTextWriter.WriteLine("public override string ToString()");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;

            //indentedTextWriter.WriteLine("return \"I am autogenerated\";");
            WriteToStringMethodBody(indentedTextWriter, context, type);
            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");

            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");

            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");
        }
        private static void WriteToStringMethodBody(IndentedTextWriter indentedTextWriter, SourceGeneratorContext context, INamedTypeSymbol type)
        {
            indentedTextWriter.Write("return $\"");
            var stringValueInMethod = new StringBuilder();
            var count = 0;
            foreach (var propertySymbol in GetSymbolsForToString(type))
            {
                var isString = propertySymbol.Type.SpecialType.ToString() == "System_String";

                stringValueInMethod.Append(count > 0 ? " " : string.Empty);
                stringValueInMethod.Append($"{propertySymbol.Name}{_propertySeparator}"); // Add propertyName + separator
                stringValueInMethod.Append($" "); // Add space
                stringValueInMethod.Append(isString ? "\\\"" : string.Empty); // Add \" if it's a string
                stringValueInMethod.Append($"{{{propertySymbol.Name}}}");     // Add {propertyName}
                stringValueInMethod.Append(isString ? "\\\"" : string.Empty); // Add \" if it's a string
                stringValueInMethod.Append($"{ _valuesSeparator}"); // Add value separator

                count++;
            }

            // remove traling separator
            stringValueInMethod.Length -= _valuesSeparator.Length;
            indentedTextWriter.Write(stringValueInMethod);
            indentedTextWriter.Write("\";");
        }
        private static IEnumerable<IPropertySymbol> GetSymbolsForToString(INamedTypeSymbol type)
        {
            foreach (var typeProperty in type.GetMembers().Where(t => t.Kind == SymbolKind.Property))
            {
                if (typeProperty is IPropertySymbol propertySymbol)
                {
                    if (propertySymbol.DeclaredAccessibility == Accessibility.Public || propertySymbol.DeclaredAccessibility == Accessibility.Internal)
                    {
                        yield return propertySymbol;
                    }
                }
            }
        }

        private static void Report_NoPropertiesFoundOnMethod(SourceGeneratorContext context, INamedTypeSymbol type)
        {
            // TODO Reportar mejor la localizacion
            context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                nameof(AutoToStringAttribute),
                nameof(AutoToStringAttribute),
                $"No properties found in '{type.ContainingNamespace}.{type.Name}' type to fill ToString() method.",
                $"{nameof(AutoToStringAttribute)}",
                DiagnosticSeverity.Warning,
                true),
                type.Locations.FirstOrDefault() ?? Location.None
                ));
        }
        private static void Report_ClassMustBePartial(SourceGeneratorContext context, INamedTypeSymbol type)
        {
            // TODO Reportar mejor la localizacion
            context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                nameof(AutoToStringAttribute),
                nameof(AutoToStringAttribute),
                $"'{type.ContainingNamespace}.{type.Name}' class must be partial, if '{typeof(AutoToStringAttribute).FullName}' is used",
                $"{nameof(AutoToStringAttribute)}",
                DiagnosticSeverity.Warning,
                true),
                type.Locations.FirstOrDefault() ?? Location.None
                ));
        }
        private static void Report_ClassContainsToStringWithNoArguments(SourceGeneratorContext context, INamedTypeSymbol type, IMethodSymbol method)
        {
            // TODO Reportar mejor la localizacion
            context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                nameof(AutoToStringAttribute),
                nameof(AutoToStringAttribute),
                $"Method 'ToString()' can not be overriden, in type '{type.ContainingNamespace}.{type.Name}' if has attribute '{typeof(AutoToStringAttribute).FullName}'",
                $"{nameof(AutoToStringAttribute)}",
                DiagnosticSeverity.Error,
                true),
                method.Locations.FirstOrDefault() ?? Location.None
                ));
        }
        private static bool ContainsToStringMethodWithNoArguments(ITypeSymbol type)
        {
            return GetToStringMethodWithNoArguments(type) != null;
        }
        private static IMethodSymbol GetToStringMethodWithNoArguments(ITypeSymbol type)
        {
            var toStringMembers = type.GetMembers("ToString");
            foreach (var toStringMember in toStringMembers)
            {
                if (toStringMember is IMethodSymbol toStringMethodSymbol)
                {
                    if (toStringMethodSymbol.Parameters.Length == 0)
                        return toStringMethodSymbol;
                }
            }
            return null;
        }


    }
}
